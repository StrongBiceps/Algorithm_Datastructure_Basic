2023.07.26 
# N - ary Tree
<n항 트리를 이용한 file_system 구현>
리눅스 운영체제의 디렉토리 계층 구조를 n항 트리를 이용하여 구현했다.

1.기본적인 N-항 트리를 구성한다. 이 트리의 노드는 디렉토리 또는 파일의 이름, 그리고 이것이 파일인지 디렉토리인지를 분간하는 플래그 멤버로 갖는다.
2.현재 디렉토리를 저장할 데이터 멤버를 추가한다.
3.단일 디렉토리 루트로 트리를 초기화한다.
4.경로명을 인자로 받는 디렉토리/파일 검색 함수를 추가한다. 상대 경로와 절대 경로 모두를 지원한다.
5.현재 디렉토리를 변경하는 함수를 추가한다.

인터페이스와 함수의 구현을 분리하고 함수를 캡슐화하기 위해 public section에 인터페이스 메소드를 정의하고 내부에서 impl 메소드를 호출한다.
따라서 사용자는 impl 메소드에는 접근할 수 없다.

# Median Algorithm

<최대 힙과 최소 힙을 이용한 중앙값 알고리즘>

최대 힙과 최소 힙을 캠슐화한 median 클래스로 입력된 원소들의 중앙값을 구하는 알고리즘

1.중앙값을 기준으로 작은 값들은 최대 힙으로 들어가고 큰 값들은 최소 힙으로 들어간다.
사이즈 비교를 하는 이유는 중앙값을 기준으로 두 힙의 크기가 균등하게 유지되어야 하기 때문이다.
2.각 Heap의 top값을 더한 후 2로 나눈 값이 입력된 원소들의 중앙값이 된다.

# Data list Merge Algorithm

<힙을 이용한 데이터 리스트 병합>

1.각각의 리스트는 이미 정렬되어 있기 때문에, 각 리스트의 최소 원소는 맨 앞에 위치한다. 이들 원소로부터 최솟값을 빠르게 선택하기 위해
힙을 사용한다.
2.힙에서 최소 원소를 가져온 후 이를 제거하고, 최소 원소가 있던 리스트에서 그 다음으로 작은 원소를 선택해 힙에 추가한다.
3.힙의 노드는 이 원소를 어느 리스트에서 가져왔는지, 또한 해당 리스트에서 몇 번째 원소인지를 저장해야 한다.

이 알고리즘의 시간복잡도는 리스트가 k개 있다면 힙의 크기는 k가 되고 모든 힙 연산의 시간복잡도는 log k가 된다. 힙을 구성하는 데는
O(log k)가 된다. 그런 다음 각 원소에 대해 힙 연산을 수행해야 한다. 전체 원소 갯수는 N*k개이다. 그러므로 전체 시간복잡도는
N*klog k이다.

# Hash_Map (modulo operation)

<모듈로 연산을 이용하여 해시 맵 구성>

이 코드는 해시 맵의 작동 원리를 간단하게 공부할 수 있는 예제코드이다.

단순하게 해시 함수를 모듈로 연산으로 사용하여 해시 맵을 구성한다. 이 방식은 간단하지만 해시 값의 중복이 일어날 수 있다.
룩업 상황에서 모듈로 연산을 통해서 구한 index로 접근하기 때문에 빠르고 간단하다.

아직 충돌에 대해서는 깊게 생각하지 않은 해시 맵이다.
