std::binary_search //이진 검색을 이용하여 컨테이너에서 원소 하나를 찾는다.
std::search() //컨테이너에서 일련의 원소들을 찾는다.
std::upper_bound() //컨테이너에서 주어진 값보다 큰 원소가 나타나기 시작하는 위치의 반복자를 반환한다,
std::lower_bound() //컨테이너에서 주어진 값보다 작은 원소가 나타나기 시작하는 위치의 반복자를 반환한다.
std::partition() //분할 연산을 수행하고, 주어진 피벗보다 작은 원소는 피벗 왼쪽으로 옮기고 피벗보다 큰 원소는 오른쪽으로 옮긴다.
std::partition()_copy() //분할 연산을 수행하고, 그 결과를 별도의 두 배열로 반환한다.
std::is_partitioned() //주어진 피벗을 기준으로 분할이 되어 있는지를 검사한다.
std::stable_partition() //분할 연산을 수행하며, 각 파티션 원소는 원본 순서를 유지한다.
std::sort() //컨테이너 원소를 정렬한다. 내부적으로 여러 정렬 알고리즘을 조합하여 사용한다.quick_sort와 insertion_sort를 조합하여 사용한다.
std::stable_sort() //컨테이너 원소를 정렬하되, 서로 순위가 같은 원소에 대해 원본 순서가 변경되지 않도록 정렬한다.
std::partial_sort() //컨테이너 전체가 아니라 일부 구간에 대해서 정렬한다.
std::merge() //두 개의 입력 컨테이너를 합친다. 이때 두 컨테이너의 원소 순서는 그대로 유지된다.
std::nth_element() /*컨테이너에서 n번째로 작은 원소를 반환한다.C++ 표준 라이브러리의 nth_element 함수의 경우 IntroSelect 라는 방식을 사용하는데
, 이는 피벗을 고를 때 원소 3 개를 골라서 그 중 중간값을 피벗으로 고르는 방식을 사용하다가, 이 방식으로 진행이 너무 더디다면
Medians of medians 알고리즘을 사용하는 방식으로 바뀌는 혼합된 방식으로 사용한다.*/
std::accumulate() //컨테이너 원소의 누적 합을 계산한다. 이 함수는 다른 외부 함수를 지정하여 누적 합이 아닌 다른 연산을 수행할 수도 있다.
std::transform() //컨테이너와 함수가 주어지면, 컨테이너의 모든 원소에 대해 해당 함수를 적용하여 값을 수정한다.
std::reduce() [C++17] //지정한 범위의 원소에 대해 리듀스 연산을 수행하고 결과를 반환한다.